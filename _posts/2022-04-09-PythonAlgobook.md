# Pythonからはじめるアルゴリズムトレードのメモ
## Chapter 2
* mini conda をパッケージマネージャーおよび仮想環境として効率的な方法
* Dockerを用いて mini conda なども設定可能．
* クラウドインスタンスは[DigitalOcean](https://www.digitalocean.com/)がよいらしい．

## Chapter 3
* HDFstoreによるデータの高速保存と読み込み
* 追加検索可能はto_hdf()メソッド
* バックテストで有意義らしい．

## Chapter 4
* ベクトルはリストでなく，NumPyによるn次元配列が対応
* data['return'] はnpでlogリターンを計算．data['strategy']はdata['position']をshift(1)してリターンとの積
* グロスリターン（累積リターン）は.apply(np.exp)．
* max DDやDDの最長時間なども可視化できる．
* モメンタムは執行コストとの戦い．比較的に長い足がベター(Moskwiz, et. al. 2012)
* 平均回帰はおそらくボラの時間的な変化が安定的なものにワーク．
* 回帰についての予想について．正解率が高ければいいうものでない．最悪の日から逃れ，最高の日で予想できることが肝．
  * タイミングの問題とあるが，賭ける資産がよく動くときに予想が当たるかどうか？という問題
  * 賭ける資産を予想するでなく，リターンを予想する．つまり，リターン分布におけるtailにおける正答率との関係．
  * 価格は直前に説明力があるが，リターンは全く異なってほぼない．なにせ過去N期間の価格の関数になっているから．
  * リターンは正規分布と単純化すればトリガーによる戦略は下から （トリガー超えにおける正解率）× （トリガー超えのtail確率）で下に有界．
  * したがってボラが大きいことはプラスに作用し，大事なことは比較的に大きめの変動のときの正解率．
* DNNはkreasとTensorFlowで簡単に実装できる．
  * 過去のlagを用いて対数リターンを予想させる．つまり，先っぽの確率にウエイトがかかり，そこを予想をしている
  * OOSでも最初にまごつくとある．これは十分な期間のリターンを予想しているから当然．（虎穴に入らずんば虎子を得ず）
  * OOSでも優位性がありそうにみえる．lagだけでなく特徴量を込みすると改善する



### To do
- [ ] dockerを用いて上のmini conda環境を揃えてみる
- [ ] DropletsについてRSA公開鍵と秘密鍵を作成してセキュア環境の設定


